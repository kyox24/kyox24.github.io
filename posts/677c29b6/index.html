<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>PCGBook读书笔记｜第三章 地牢和关卡的结构性生成 | Foggy World</title><meta name="keywords" content="PCG"><meta name="author" content="Kyox24"><meta name="copyright" content="Kyox24"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="PCGBook第三章的读书笔记，主要介绍了地牢关卡生成的内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="PCGBook读书笔记｜第三章 地牢和关卡的结构性生成">
<meta property="og:url" content="https://foggyworld.life/posts/677c29b6/index.html">
<meta property="og:site_name" content="Foggy World">
<meta property="og:description" content="PCGBook第三章的读书笔记，主要介绍了地牢关卡生成的内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kyox24/PicBed/PCGBOOK_COVER2.png">
<meta property="article:published_time" content="2021-07-04T02:53:07.000Z">
<meta property="article:modified_time" content="2021-07-04T02:55:59.492Z">
<meta property="article:author" content="Kyox24">
<meta property="article:tag" content="PCG">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/kyox24/PicBed/PCGBOOK_COVER2.png"><link rel="shortcut icon" href="/images/GAME%20CONSOLE.png"><link rel="canonical" href="https://foggyworld.life/posts/677c29b6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 11:55:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="/style/showbb_in_index.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/头像.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/bb/"><i class="fa-fw fas fa-quote-left"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Foggy World</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/bb/"><i class="fa-fw fas fa-quote-left"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">PCGBook读书笔记｜第三章 地牢和关卡的结构性生成</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-04T02:53:07.000Z" title="发表于 2021-07-04 11:53:07">2021-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-04T02:55:59.492Z" title="更新于 2021-07-04 11:55:59">2021-07-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PCGBook读书笔记｜第三章 地牢和关卡的结构性生成"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><div class="note warning flat"><p>以下部分内容由于结合了自己的理解，部分内容和原书可能并不一致，并省略了本章中的3.8、3.9部分。</p>
</div>
<h2 id="地牢关卡"><a class="markdownIt-Anchor" href="#地牢关卡"></a> 地牢关卡</h2>
<hr />
<p>地牢这一概念的源头被认为是《龙与地下城》，广泛地影响现代电子游戏，在这些游戏中与本书讨论的内容相关程度十分高的一类游戏便是rouguelike游戏，来源于1980年的《rougue》其特点是程序化运行的地牢生成。</p>
<p>在本章中地牢被定义为一种游戏中的迷宫式环境，主要由相互关联的挑战、奖励和谜题组成。含有这种要素的游戏在设计师，游戏设计师需要严格把控游戏时间和空间上的节奏，例如玩家可以在不同的分岔路中自由选择，但是绝不会遇到比自己强大太多的怪物。因此设计这类游戏是一项复杂的工作。</p>
<p>地牢在结构上通常由几个房间组成，通过走廊相连接，在地牢的生成中除了地牢的形状和整体的拓扑结构之外，地牢中包括NPC或者宝箱等游戏物品，在下图中可以看到地牢的形状与整体的拓扑结构：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210527165448.png" style="zoom:50%;" />
<p>关于地牢的PCG一般就是指生成地牢的形状、整体的拓扑结构以及游戏物品，一般包含以下三个要素：</p>
<ul>
<li>代表性模型，即一个抽象的、简化后的可以代表地牢结构的模型</li>
<li>生成代表性模型的方法</li>
<li>从代表性模型生成地牢形状的方法</li>
</ul>
<p>在本章接下来的内容中将会介绍几种生成地牢关卡与平台跳跃游戏关卡的方法，它们有着一个共同点，即都是<strong>建设性的（Constructive）</strong>，这类方法相对于基于搜索的方法的不同为每次运行只产生一个结果，而不是基于搜索的生成一系列结果再从中搜索好的结果。因此，建设性的方法一般运行速度较快，甚至有可能在玩家的游玩进程中生成关卡，但是对于这类方法的控制程度（指根据用户需求生成相应内容的能力）是比较低的，或者为了提高控制程度的同时保证多样性需要付出很多努力。</p>
<h2 id="基于空间分割space-partitioning的地牢生成"><a class="markdownIt-Anchor" href="#基于空间分割space-partitioning的地牢生成"></a> 基于空间分割（Space Partitioning）的地牢生成</h2>
<hr />
<p>所谓空间分割指的是把一个二维或者三维空间细分为几个互不相干的子集，从而使空间中任何一点都恰好属于这些子集中的一个。在这种方法中往往采用递归的思想，也就是说对于子集可以进行进一步的空间分割。因为这种递归思想，很自然地树结构便成为了这种方法中最常用的数据结构，一般被称为空间分割树（Space Partitioning Tree）。这样一来，对空间中的任意点进行查询将会变得快捷便利，正因为这种便捷，空间分割树在计算机图形学中也尤为重要，可以实现高效的射线投影（Raycasting）、视锥体剔除（Frustum Culling）和碰撞检测（Collision Detection）等。</p>
<p>最流行的空间分割方法是二叉分割，即递归地将一个空间划分为两个子集，这样构成的树被称为空间分割二叉树（Binary Space Partitioning Tree，BSP Tree）。</p>
<p>BSP树的两个重要变体是<strong>四叉树</strong>和<strong>八叉树</strong>，四叉树递归地将一个二维空间划分为四个子集而八叉树则递归地将一个三维空间划分为八个子集。以二维空间的四叉树作为例子，理论上一个深度为n的四叉树可以表示任何像素为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mo>×</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n \times 2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span>的二进制图像，下图是一个例子：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210527190910.png" style="zoom:50%;" />
<p>上面图中二进制的图像大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn><mo>×</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">16\times 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>，数据为0时显示红色，1时显示黑色，可以看到部分区域并没有被完全细分，因为这是没有必要的，一般只要保证叶子节点的图像中数据相同（同一个颜色）即可。从这个例子中可以看出，空间分割方法用于对二维或者三维图像的表示时可以保证分割出的区域不会发生重叠，这一性质对于地牢生成来说是十分宝贵的，接下来便讨论如何利用这种方法生成地牢。</p>
<p>完全沿用上面的思想，当给定一个一个四叉树的结构（无需带有数据）时，我们随机决定叶节点中的数据是0（代表空）或者1（代表地牢迪的地块），就可以生成一个地牢的完整拓扑结构，如下图：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210527193505.png" style="zoom:50%;" />
<p>可以看到按照上述生成方法生成的地牢结构十分规整，当开发者想生成不这么规整的地牢结构时可以适当放宽限制，如给定四叉树结构后，对于每个叶节点，可以随机生成一个小于等于这个叶节点所代表面积的地牢，最后再通过其他随机方法把这些地牢连接起来即可，效果如下：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210527194454.png" style="zoom:50%;" />
<p>上面的方法可以生成大小不同的地牢房间，但最小单位都基于一个固定大小的像素块，对于此可以更进一步放宽限制。比如可以随机地对要创建地牢的区域进行水平方向与竖直方向的分割，并设定一个区域的最小大小，当区域小于这一大小时就不再对其进行进一步分割。对于这样的分割后的区域也可以通过一个BSP树来存储，连接地牢时只需把拥有同一父节点的节点连接到一起即可，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始化地牢区域，同时把此作为BSP树的根节点</span><br><span class="line">在竖直或者水平方向上分割地牢区域</span><br><span class="line">在被分割出的两块子区域中选择一个</span><br><span class="line">if 这个子区域的大小 &gt; 指定的最小大小:</span><br><span class="line">	go to 2 (即对此子区域进行进一步划分)</span><br><span class="line">选择另一块子区域并go to 4</span><br><span class="line">对所有分割出的子区域:</span><br><span class="line">	在子区域中随机创建地牢房间（具体做法是随机选择区域中两点，作为地牢房间的左上和右下）</span><br><span class="line">从最底层的节点开始，把拥有同一个父节点的区域中的地牢房间连接在一起</span><br><span class="line">repeat 9 until 所有房间都被连接  </span><br></pre></td></tr></table></figure>
<p>以下是分割时的示意图：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210605000546.png" style="zoom:50%;" />
<p>以下是连接时的示意图：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210605000621.png" style="zoom:50%;" />
<p>从上面的利用BSP数的层级关系来连接地牢房间的例子中我们可以看出，我们显然可以利用BSP树做一些其他事，例如我们可以用非叶子结点来定义地牢的主题，主题指的是，例如拥有更高等级的怪物或者隐藏房间，下图是一个例子：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210605001520.png" style="zoom:50%;" />
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210605001055.png" style="zoom:50%;" />
<p>从上图中，我们结合BSP树可以得知，最大的两个分区B、C被一道绿色的门分隔开来，同时同一层级的地牢房间的主题相同。</p>
<h2 id="基于代理agent-based的地牢生成"><a class="markdownIt-Anchor" href="#基于代理agent-based的地牢生成"></a> 基于代理（Agent-based）的地牢生成</h2>
<hr />
<p>基于代理的地牢生成指的是，通过使用一个代理在地牢空间中“挖掘”出走廊和房间，与基于空间分割的方法相比，这类方法的着目点更加微观，因此虽然有可能生成出十分有机分布的地牢房间也有可能生成出十分混乱的地牢。同时，在这一方法中，代理的参数设置对于生成效果的影响往往只能通过试错得知，这也与具有可预测性的基于空间分割方十分不同。接下来会介绍两种不同的基于代理的地牢生成方法。</p>
<p>首先，是一种随机性很高的“盲目”代理，首先把代理置于地牢空间中的随机位置并随机在上下左右中选择一个方向进行“挖掘”，在第一次“挖掘”之后，该代理有5%的概率改变方向，有5%的概率创建一个随机大小的房间。在之后的行动中，如果向着与上一次移动方向相同的方向进行“挖掘”的话，则改变方向的概率会增加5%，如果没有创建房间的话，创建房间的概率也会增5%，直到改变了方向或者创建了房间之后，其相应的概率就清零，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">初始化改变方向的概率Pc &#x3D; 5</span><br><span class="line">初始化创建房间的概率Pr &#x3D; 5</span><br><span class="line">将代理放置于地牢空间中，并随机设定其方向</span><br><span class="line">沿着该方向进行挖掘</span><br><span class="line">取0到100之间的一个随机数Nc</span><br><span class="line">if Nc &lt; Pc:</span><br><span class="line">	随机为代理选择一个新的方向</span><br><span class="line">	Pc &#x3D; 0</span><br><span class="line">else:</span><br><span class="line">	Pc &#x3D; Pc + 5</span><br><span class="line">取0到100之间的一个随机数Nr</span><br><span class="line">if Nr &lt; Pr:</span><br><span class="line"> 取3到7之间的两个随机数作为房间的长和宽</span><br><span class="line"> 将房间放置于代理周围</span><br><span class="line"> Pr &#x3D; 0</span><br><span class="line">else:</span><br><span class="line">	Pr &#x3D; Pr + 5</span><br><span class="line">if 地牢的规模未达预期:</span><br><span class="line"> go to 4</span><br></pre></td></tr></table></figure>
<p>效果如下图：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210623013716.png" style="zoom:50%;" />
<p>从上图中可以看到，使用在这种方法时，即便只经历了几次迭代也已经出现了死路和重叠的房间，为了避免这种情况，可以降低代理的随机性来使得代理更有“前瞻性”，具体为代理会检查当前位置创建房间后会不会导致房间重叠，如果不会才创建，下面是伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">将代理放置于地牢空间中</span><br><span class="line">设置两个辅助变量，Fr &#x3D; 0, Fc &#x3D; 0</span><br><span class="line">for 所有的房间的可能尺寸:</span><br><span class="line">	if 要创建的房间不与现有的房间发生重叠:</span><br><span class="line">		将房间放置于代理周围</span><br><span class="line">		Fr &#x3D; 1</span><br><span class="line">		break</span><br><span class="line">for 所有走廊的可能方向及尺寸:</span><br><span class="line">	if 要创建的走廊不与现有的房间发生重叠:</span><br><span class="line">		创建走廊</span><br><span class="line">		Fc &#x3D; 1</span><br><span class="line">		break</span><br><span class="line">if Fr &#x3D; 1 or Fc &#x3D; 1:</span><br><span class="line">	go to 2</span><br></pre></td></tr></table></figure>
<p>效果如下图：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210626165331.png" style="zoom:50%;" />
<p>从上图中可以看到，使用在这种方法时，虽然不会出现房间重叠和死路的情况，但是在最后一张图的迭代后，即便整个区域还有许多空白，但由于算法设置所以停止了生成。</p>
<p>上述的两种个例子都是基于代理的生成中比较简单的方法，两张效果图也是在很大程度上显示了各算法最差的运行结果，产生的地牢要么重叠，要么过早停止生成。对代理的行为添加更多的代码也许能够解决类似的问题，但在实际的工作中如果没有充分地进行试错，往往很难预见到类似问题的发生。换句话说，这种算法的不可控性的好的一面是，可能导致有机的、十分拟真的地图同时还能减少玩家对地图的可预测性，坏的一面则是可能导致地图补课完或者没有游戏性。这种基于代理的方法的参数会对生成内容的各方各面产生很大的影响，而调整这些参数以达到最佳的生成效果并不是一项简单的工作。</p>
<h2 id="元胞自动机"><a class="markdownIt-Anchor" href="#元胞自动机"></a> 元胞自动机</h2>
<hr />
<p>元胞自动机是一种离散的计算模型，在计算机科学、物理学甚至一些生物学的分支中被广泛使用和研究。接下来对元胞自动机的概念进行简单说明。</p>
<p>元胞自动机包含一个n维的网格、一组状态和一组状态转移规则。形式上，一维和二维的元胞自动机可以被表示为向量和矩阵，状态也可以是最简单的只有on和off。元胞自动机从初始状态开始根据某种规则进行进化，具体表现为在每个时刻t，每个元胞都根据t-1时刻的自身状态以及周围领域中的元胞状态来决定下一个状态。</p>
<p>关于“周围领域”的定义，在一维元胞自动机中，可以通过往左或者往右延伸了多少个单位来定义。在二维元胞自动机中有下图的两种常见的形式， <em>Moore neighbourhoods</em> 和 <em>von Neumann neighbourhoods</em> ，他们的的大小也可以任何整数。</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210702145737.png" style="zoom:50%;" />
<p>元胞自动机的状态数回随着周围领域的增大而指数上升，例如只有两个状态的元胞自动机的周围领域是大小为2的<em>Moore neighbourhoods</em> 时，状态数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>25</mn></msup><mo>=</mo><mn>33</mn><mo separator="true">,</mo><mn>554</mn><mo separator="true">,</mo><mn>432</mn></mrow><annotation encoding="application/x-tex">2^{25}=33,554,432</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">5</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">3</span><span class="mord">2</span></span></span></span>，对于有较小的周围领域的元胞自动机，状态转移规则通过一张表来定义，对于有着大周围领域的元胞自动机，通常基于控制处于每个状态的元胞的比例来定义状态转移规则。</p>
<p>元胞自动机是非常通用的，有几种类型的元胞自动机已经被证明是图灵完备的，在这里我们主要关注其如何在程序化内容生成中被使用。</p>
<div class="note prime flat"><p>图灵完备的定义：一个计算系统可以计算任何图灵-可计算函数，被称作图灵完备。具体参见<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20115374">什么是图灵完备？</a></p>
</div>
<p>Johnson等人<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>提出了一种用元胞自动机生成无限大小的洞穴状地牢的系统，这种地牢的地图中仅有<strong>岩石</strong>和**道路（空）**两种元素。另外，游戏画面并不滚动，而是一屏一屏地展示环境，这就提供了一个几百毫秒的时间窗口，在玩家每次退出房间时，都可以有时间来创建一个新的房间。</p>
<p>在他们提出方法中，可以用以下的四个参数来控制地图的生成过程：</p>
<ul>
<li>岩石的百分比</li>
<li>元胞自动机的生成次数</li>
<li>关于何时生成岩石的阈值T</li>
<li>周围领域的数量</li>
</ul>
<p>每个房间都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn><mo>×</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">50 \times 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>的网格，每个元胞有两种状态，<strong>岩石</strong>或<strong>道路（空）</strong>，初始状态下是全空的，具体的生成过程如下：</p>
<ul>
<li>对于每个元胞根据事先确定好的概率变化为岩石</li>
<li>对这一网格使用元胞自动机迭代n步，迭代时的转移规则为，如果一个元胞的周围至少有T个岩石，那么它将变化为岩石，否则则变化为道路</li>
<li>为了保证地图美观，岩石区域与道路（空旷区域）接壤的部分在外观上会显示为类似于“墙”的图形</li>
</ul>
<p>下图为生成结果：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210702154857.png" style="zoom:50%;" />
<p>仅用上述的方法还不能保证地图与地图之间自然衔接。因此，每当一个地图被生成时，其紧邻的地图也会被生成，如果两张地图的连接处，空区域最大的地方没有相互接壤，就在这两个空区域之间生成一个隧道，之后再对整个区域（例如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn><mo>×</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">50 \times 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>大网格地图）进行两次元胞自动机的迭代来摩平尖锐边缘，下图为生成的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn><mo>×</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">50 \times 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>大网格地图：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210702155747.png" style="zoom:50%;" />
<p>上述方法的优点是，参数少且直观，但同时因为每个参数都会影响地图的多个特征，我们很难使用这种方法去创建一个有特定要求的地图。因此，在一定程度上我们可以说在上述方法中参数和游戏特征并不是直接相关的，任何参数与生成结果之间的联系都需要经过大量的实验来建立。</p>
<h2 id="基于语法grammar-based的地牢生成"><a class="markdownIt-Anchor" href="#基于语法grammar-based的地牢生成"></a> 基于语法（Grammar-based）的地牢生成</h2>
<hr />
<div class="note warning flat"><p>在这一部分，有较多不太了解的概念，如生成语法（Generative Grammars）和形状语法（Shape Grammars）等，在写博客时仅总结PCGbook原文的内容，并附上相关学习资料。</p>
</div>
<p>生成语法（Generative Grammars）最早是为了描述自然语言的结构才被定义的，但在其他领域中也常被使用。</p>
<div class="note prime flat"><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20382899">生成语法学研究的是什么?</a>，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/%E7%94%9F%E6%88%90%E6%96%87%E6%B3%95">生成语法Wiki</a></p>
</div>
<p>Adams<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>使用图形语法（Graph Grammars）来生成FPS游戏的关卡，更具体地说，他使用图形语法的规则来生成一个描述关卡拓扑结构的图形，其中节点代表房间，两个房间之间若有边则意味着它们是相邻的。值得注意的是，这样的方法不产生任何例如房间大小等的几何细节。这样做的优点是，可以通过难度或乐趣度等参数来控制关卡的生成。</p>
<p>这种方法的一个局限性是在应用至不同的游戏关卡生成时都需要重新建立语法规则，但同时这种方法在展示了通过gameplay来控制地牢生成的动机和重要性方面有着比较大的贡献。</p>
<p>Dormans<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>也使用了生成语法来生成冒险游戏的地牢空间，通过一个图形语法，一次冒险任务（地牢房间）首先以有向图的形式生成，它将会作为玩家需要完成的连续冒险的模型。随后，每个冒险任务都会被抽象为一个节点和边的网格，然后被形状语法（Shape Grammars）用来生成相应的游戏空间。</p>
<div class="note prime flat"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50443028">生成式艺术和算法创作06-形状语法</a>，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shape_grammar">形状语法Wiki</a></p>
</div>
<p>这一个成功引入了基于gamplay来控制生成的方法，但是没有提供控制参数，因为这种方法中的“控制”是由图形语法和形状语法中的不同规则来施加的，这对大多数人来说远远不够直观。</p>
<p>受到上述方法的启发，van der Linden等人<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>提出了使用gamplay语法来生成地牢关卡的方法。游戏设计者首先使用一个面向gameplay的词汇表来表达先验的设计约束，这种词汇表油玩家在游戏中要执行的动作、这些动作的顺序和构成、内在联系和一些相关内容组成。这些由设计者编写的约束条件就可以被看为一个生成性的图形语法，也就是“gamplay语法”。这种语法会产生玩家行动的图，随后决定地牢关卡的布局，这些具体的关卡内容是按照图的约束条件来合成的。在一些被提出的算法中，将图映射到游戏空间来完成关卡的生成。另一方面，也有使用程序性方法根据图的要求为地牢房间和走廊生成几何图形的算法。</p>
<p>这种方法的目的是引入基于gamplay来控制生成的方法的同时，保证其一定的通用性。van der Linden等人为设计者提供了一个可以有效地从零开始创建基于语法的关卡生成器的工具。这个工具并不是只适用于某一特定游戏，所以这种方法是通用的。然而，对于特定的游戏虽然能够使用通用工具生成一个玩家行动图，我们仍然需要一个额外的可以基于玩家行动图生成实际游戏关卡的生成器。van der Linden等人仅在Dwarf Quest<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>一个案例中展示了生成效果，如下图：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210703163846.png" style="zoom:50%;" />
<h2 id="先进的平台跳跃游戏关卡生成方法"><a class="markdownIt-Anchor" href="#先进的平台跳跃游戏关卡生成方法"></a> 先进的平台跳跃游戏关卡生成方法</h2>
<hr />
<p>接下来，我们将注意力转向平台的生成方法，讨论两个最近提出的用于生成平台跳跃游戏关卡的方法。与前几节不同的是，我们没能对这些方法的特点进行分类（如上面的基于代理或语法等），但这些方法的中心概念都可以很好地促进改善地牢的生成。</p>
<p>第一种方式是由Smith等人<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>等人提出的基于节奏的平台跳跃游戏关卡生成。在这个研究中，平台跳跃游戏关卡的节奏是指玩家行动的时间点和重复。他们首先使用一种两层结构的基于语法的方法来生成关卡的小片段，这种片段被称为节奏组。这里的两层结构中，第一层负责创建一组玩家动作，之后这组动作被转换为相应的几何图形。关卡的创建则是通过尝试连接几个节奏组后并使用一套评价方法来选出最佳关卡。</p>
<p>在这个方法中，Smith等人还提出了一组“旋钮”，设计者可以通过操作这些旋钮来控制生成过程，具体有：</p>
<ul>
<li>关卡中的玩家的移动路径</li>
<li>要生成的节奏种类</li>
<li>几何组件的类型和频率</li>
<li>收集品在关卡中的分配方式</li>
</ul>
<p>同时，对于每个节奏组也有一些参数，具体有：</p>
<ul>
<li>跳跃频率</li>
<li>特定的几何形状</li>
<li>发生跳跃的最长时间间隔</li>
<li>节奏长度</li>
<li>节奏密度</li>
<li>节拍类型</li>
<li>节拍模式</li>
</ul>
<p>这个方法在不同的抽象层次上提供了大量的参数控制生成效果，所以能够生成十分多样的关卡。另外，这种方法和gameplay的联系十分紧密，特别是在平台跳跃游戏中，但也存在可以应用至地牢生成的可能性。这个方法与前节中介绍的Dormans的方法一样，使用了两层结构的语法，第一层考虑gameplay，第二层考虑实际的游戏空间。虽然平台游戏中的节奏这一概念并不能直接使用于地牢，但穿过地牢房间和走廊的速度在基于地牢的游戏中可能具有类似的节奏特征。因此，将一个平台跳跃游戏关卡分解成节奏组与将一个地牢分成具有不同特征的地牢组之间有着千丝万缕的联系。</p>
<p>接下来介绍第二个方法由Mawhorter等人<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>提出。这一方法被称为ORE（Occupancy- Regulated Extension），它的目的是直接程序性地生成2D平台跳跃游戏关卡。同时这种算法是通用的，它支持在任意尺度上基于人类设计的关卡来进行生成。与第一种方法不同，这个方法需要人类设计师预先设计好的关卡块，然后再使用算法通过从含有所有关卡块的库中挑选并组合关卡块来生成完整的关卡。具体的步骤如下：</p>
<ul>
<li>随机选择一个玩家位置来定位一个关卡块</li>
<li>从关卡块列表中选择一个合适的关卡块</li>
<li>把新的关卡块整合进现有关卡中</li>
</ul>
<p>Mawhorter等人没有提到ORE算法中的具体参数，但从算法思想上来看，游戏设计者在使用这一算法时仍拥有一定的对生成关卡的控制能力。关卡块库的关卡块种类和各个关卡块的出现概率都可以被看作是隐性参数。同时，从另一个角度看，这种生成方法是通过人类与机器的协作而完成的，人类在设计时关卡块便是在对生成关卡进行一种很大程度的控制。然而，在比较极端的情况下，这种方法可能太接近于纯手工构建关卡，从而降低了使用PCG的好处。另外，显然这种方法对于地牢关卡的生成也很有启发性，设计者可以设计一组地牢模板库，让算法负责组建完整的关卡。</p>
<h2 id="平台生成的实例应用"><a class="markdownIt-Anchor" href="#平台生成的实例应用"></a> 平台生成的实例应用</h2>
<hr />
<h3 id="spelunky"><a class="markdownIt-Anchor" href="#spelunky"></a> Spelunky<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup></h3>
<p>Spelunky是一个2D平台跳跃游戏。玩法包括了收集通过所需的物品和同敌人战斗等。游戏由四组难度递增的地图组成。每组关卡都有不同的布局，并引入了新的挑战和新类型的敌人。下图是第二组关卡中的一个实例：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210703235740.png" style="zoom:50%;" />
<p>如下图，Spelunky中的每个关卡都被划分为一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">4\times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>的网格，即由16个房间组成，其中有两个标志着关卡的开始和结束。不是所有的房间都是相互连通的，有一些孤立的房间（如左上角和右下角），为了达到这些房间，玩家需要使用炸弹这类有限资源来摧毁墙壁。</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210704000100.png" style="zoom:50%;" />
<p>在Spelunky中每个房间的布局都是从一组预定义的模板中选择的。下图是一个例子：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210704000641.png" style="zoom:50%;" />
<p>在每个关卡模板中，都事先标出了一些可以发生随机化的区块。每当生成一个关卡时，这些区块会根据一组随机数字发生器<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>被不同类型的障碍物所取代。按照这种方法，在算法的每一次运行中都可以生成一个新的关卡。</p>
<p>更具体地说，一个Spelunky的每个房间都由80个tile组成，如下图可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mo>×</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">8\times10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>的矩阵表示， 其中0代表空，1代表墙壁或者砖块，L代表梯子，6代表可以发生随机化的区块：</p>
<img src= "/images/Ripple.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/20210704001243.png" style="zoom:50%;" />
<p>总的来说，Spelunky的关卡生成可以看作由以下三个主要阶段组成：</p>
<ul>
<li>通过从模板库中选择房间布局模板，并定义关卡的开始和结束来生成关卡的主要布局</li>
<li>障碍物生成，在这一阶段中可以认为我们使用了一个代理遍历关卡，然后根据一套启发式方法在关卡中放置障碍物</li>
<li>怪物生成，同样可以被认为是通过代理在关卡中搜索合适空间放置怪物</li>
</ul>
<h3 id="infinite-mario-bros"><a class="markdownIt-Anchor" href="#infinite-mario-bros"></a> Infinite Mario Bros</h3>
<p>IMB（Infinite Mario Bros）<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>是《超级马里奥兄弟》的克隆版，每次开启新游戏时，关卡都是根据某些启发式方法添加特征而随机生成的。IMB中的关卡是一个二维矩阵，已经有许多研究提出了不同的手法来生成IMB游戏关卡<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup><sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup><sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup><sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>，接下来会描述一种可能的方法。</p>
<p>Ben Weber<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>提出了PMPG（Probabilistic Multi-pass Generator）算法，这一算法是基于代理的，工作方式可以看作流水线作业，首先创建基础关卡，然后通过六道工序，添加不同的游戏元素。每到工序都与一些事件（共14个）相关联，这些分布可以手动调整以来控制不同元素的出现概率。六道工序分别是：</p>
<ul>
<li>更改关卡的基础结构，如改变地板的高度或者创建一个沟壑等</li>
<li>添加背景中的山丘</li>
<li>添加静态敌人，如大炮等</li>
<li>添加移动的敌人</li>
<li>添加一些未连接的水平块</li>
<li>添加硬币</li>
</ul>
<p>使用这种方法生成的关卡的可玩性是通过对生成物品的限制来保证的。例如，生成的沟壑的宽度受到玩家可以跳过的最大块数的限制，管道的高度也受到限制，以确保玩家可以通过。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Johnson, L., Yannakakis, G.N., Togelius, J.: Cellular automata for real-time generation of infinite cave levels. In: Proceedings of the 2010 Workshop on Procedural Content Generation in Games (2010) <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Adams, D.: Automatic generation of dungeons for computer games (2002). <a target="_blank" rel="noopener" href="http://B.Sc">B.Sc</a>. thesis, University of Sheffield, UK <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Dormans,J.:Adventuresinleveldesign:generatingmissionsandspacesforactionadventure games. In: PCG’10: Proceedings of the 2010 Workshop on Procedural Content Generation in Games, pp. 1 –8. ACM (2010) <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Van der Linden, R., Lopes, R., Bidarra, R.: Designing procedurally generated levels. In: Proceedings of the the 2nd AIIDE Workshop on Artificial Intelligence in the Game Design Process, pp. 41–47 (2013) <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Wild Card: (2013). URL <a target="_blank" rel="noopener" href="http://www.dwarfquestgame.com/">http://www.dwarfquestgame.com/</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Smith, G., Treanor, M., Whitehead, J., Mateas, M.: Rhythm-based level generation for 2D platformers. In: Proceedings of the 4th International Conference on Foundations of Digital Games, FDG 2009, pp. 175–182. ACM (2009) <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Mawhorter,P.,Mateas,M.:Procedurallevelgenerationusingoccupancy-regulatedextension. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Yu, D., Hull, A.: (2009). Spelunky <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Make Games: URL <a target="_blank" rel="noopener" href="http://makegames.tumblr.com/post/4061040007/the-full-spelunky-on-spelunky">http://makegames.tumblr.com/post/4061040007/the-full-spelunky-on-spelunky</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Persson, M.: Infinite Mario Bros. URL <a target="_blank" rel="noopener" href="http://www.mojang.com/notch/mario/">http://www.mojang.com/notch/mario/</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Shaker,N.,Togelius,J.,Yannakakis,G.N.,Weber,B.,Shimizu,T.,Hashiyama,T.,Sorenson, N., Pasquier, P., Mawhorter, P., Takahashi, G., Smith, G., Baumgarten, R.: The 2010 Mario AI championship: Level generation track. IEEE Transactions on Computational Intelligence and Games pp. 332–347 (2011) <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Shaker,N.,Togelius,J.,Yannakakis,G.N.:Towardsautomaticpersonalizedcontentgeneration for platform games. In: Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment (AIIDE). AAAI (2010) <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Shaker,N.,Nicolau,M.,Yannakakis,G.N.,Togelius,J.,O’Neill,M.:EvolvinglevelsforSuper Mario Bros. using grammatical evolution. In: IEEE Conference on Computational Intelligence and Games (CIG), pp. 304–311 (2012) <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Sorenson, N., Pasquier, P.: Towards a generic framework for automated video game level creation. In: Proceedings of the European Conference on Applications of Evolutionary Com- putation (EvoApplications), pp. 131–140. Springer LNCS (2010) <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Shaker,N.,Togelius,J.,Yannakakis,G.N.,Weber,B.,Shimizu,T.,Hashiyama,T.,Sorenson, N., Pasquier, P., Mawhorter, P., Takahashi, G., Smith, G., Baumgarten, R.: The 2010 Mario AI championship: Level generation track. IEEE Transactions on Computational Intelligence and Games pp. 332–347 (2011) <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Kyox24</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://foggyworld.life/posts/677c29b6/">https://foggyworld.life/posts/677c29b6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://foggyworld.life" target="_blank">Foggy World</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PCG/">PCG</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/kyox24/PicBed/PCGBOOK_COVER2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/43392113/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/LN_ARLPCG.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Adversarial Reinforcement Learning for Procedural Content Generation | 论文笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/34633fa0/" title="Bootstrapping Conditional GANs for Video Game Level Generation | 论文笔记"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/LN_CESAGAN.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-04</div><div class="title">Bootstrapping Conditional GANs for Video Game Level Generation | 论文笔记</div></div></a></div><div><a href="/posts/352bf1e7/" title="PCGBook读书笔记｜第一章 介绍"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/PCGBOOK_COVER2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-20</div><div class="title">PCGBook读书笔记｜第一章 介绍</div></div></a></div><div><a href="/posts/a05f7909/" title="PCGBook读书笔记｜第二章 基于搜索的手法"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/PCGBOOK_COVER2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-29</div><div class="title">PCGBook读书笔记｜第二章 基于搜索的手法</div></div></a></div><div><a href="/posts/a2e72197/" title="PCGRL：Procedural Content Generation via Reinforcement Learning ｜ 论文笔记"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/LN_PCGRL3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-02</div><div class="title">PCGRL：Procedural Content Generation via Reinforcement Learning ｜ 论文笔记</div></div></a></div><div><a href="/posts/43392113/" title="Adversarial Reinforcement Learning for Procedural Content Generation | 论文笔记"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/LN_ARLPCG.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-25</div><div class="title">Adversarial Reinforcement Learning for Procedural Content Generation | 论文笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/头像.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Kyox24</div><div class="author-info__description">飞蛾扑火</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kyox24"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kyox24" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:kyo19951024@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://weibo.com/p/1005051882165114" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">缓慢搭建中</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E7%89%A2%E5%85%B3%E5%8D%A1"><span class="toc-number">1.</span> <span class="toc-text"> 地牢关卡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%88%86%E5%89%B2space-partitioning%E7%9A%84%E5%9C%B0%E7%89%A2%E7%94%9F%E6%88%90"><span class="toc-number">2.</span> <span class="toc-text"> 基于空间分割（Space Partitioning）的地牢生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86agent-based%E7%9A%84%E5%9C%B0%E7%89%A2%E7%94%9F%E6%88%90"><span class="toc-number">3.</span> <span class="toc-text"> 基于代理（Agent-based）的地牢生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">4.</span> <span class="toc-text"> 元胞自动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%AF%AD%E6%B3%95grammar-based%E7%9A%84%E5%9C%B0%E7%89%A2%E7%94%9F%E6%88%90"><span class="toc-number">5.</span> <span class="toc-text"> 基于语法（Grammar-based）的地牢生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E7%9A%84%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E5%85%B3%E5%8D%A1%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text"> 先进的平台跳跃游戏关卡生成方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E7%94%9F%E6%88%90%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text"> 平台生成的实例应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#spelunky"><span class="toc-number">7.1.</span> <span class="toc-text"> Spelunky[8]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#infinite-mario-bros"><span class="toc-number">7.2.</span> <span class="toc-text"> Infinite Mario Bros</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text"> 参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/677c29b6/" title="PCGBook读书笔记｜第三章 地牢和关卡的结构性生成"><img data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/PCGBOOK_COVER2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PCGBook读书笔记｜第三章 地牢和关卡的结构性生成"/></a><div class="content"><a class="title" href="/posts/677c29b6/" title="PCGBook读书笔记｜第三章 地牢和关卡的结构性生成">PCGBook读书笔记｜第三章 地牢和关卡的结构性生成</a><time datetime="2021-07-04T02:53:07.000Z" title="发表于 2021-07-04 11:53:07">2021-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/43392113/" title="Adversarial Reinforcement Learning for Procedural Content Generation | 论文笔记"><img data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/LN_ARLPCG.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Adversarial Reinforcement Learning for Procedural Content Generation | 论文笔记"/></a><div class="content"><a class="title" href="/posts/43392113/" title="Adversarial Reinforcement Learning for Procedural Content Generation | 论文笔记">Adversarial Reinforcement Learning for Procedural Content Generation | 论文笔记</a><time datetime="2021-05-25T07:58:48.000Z" title="发表于 2021-05-25 16:58:48">2021-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c9f13a0f/" title="TOAD-GAN在Google Colab训练时关于wandb输出的踩坑记录"><img data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/MEMO_toadganwandb.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TOAD-GAN在Google Colab训练时关于wandb输出的踩坑记录"/></a><div class="content"><a class="title" href="/posts/c9f13a0f/" title="TOAD-GAN在Google Colab训练时关于wandb输出的踩坑记录">TOAD-GAN在Google Colab训练时关于wandb输出的踩坑记录</a><time datetime="2021-05-17T15:45:00.000Z" title="发表于 2021-05-18 00:45:00">2021-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/29b10db/" title="SinGAN：Learning a Generative Model from a Single Natural Image | 论文笔记"><img data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/LN_SINGAN.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SinGAN：Learning a Generative Model from a Single Natural Image | 论文笔记"/></a><div class="content"><a class="title" href="/posts/29b10db/" title="SinGAN：Learning a Generative Model from a Single Natural Image | 论文笔记">SinGAN：Learning a Generative Model from a Single Natural Image | 论文笔记</a><time datetime="2021-05-16T14:56:44.000Z" title="发表于 2021-05-16 23:56:44">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dba5fd70/" title="one-hot编码和batch normalization的关系"><img data-lazy-src="https://cdn.jsdelivr.net/gh/kyox24/PicBed/MEMO_ONEHOT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="one-hot编码和batch normalization的关系"/></a><div class="content"><a class="title" href="/posts/dba5fd70/" title="one-hot编码和batch normalization的关系">one-hot编码和batch normalization的关系</a><time datetime="2021-05-12T02:12:49.000Z" title="发表于 2021-05-12 11:12:49">2021-05-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Kyox24</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comment-7ggp4lbmaeda677f',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comment-7ggp4lbmaeda677f',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>